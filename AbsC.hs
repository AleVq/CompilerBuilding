

module AbsC where

-- Haskell module generated by the BNF converter

{- sintax types -}

data Type 
    = Basic BasicType   
    | Pointer Type
    | ArrDef Type Integer 
  deriving (Eq, Ord, Show )

data BasicType
    = Boolean
    | T_Char
    | T_Float
    | T_Int
    | T_Void
  deriving (Eq, Ord, Show )

newtype Ident = Ident String deriving (Eq, Ord, Show )
data Boolean = True | False
  deriving (Eq, Ord, Show )

data Program = Prog [Decl]
  deriving (Eq, Ord, Show )

{- sintax declarations -}

data Decl
    = Dvar Type [VarDeclar]
    | Dfun Type Ident [Parameter] [Stmt_Decl]
  deriving (Eq, Ord, Show )

data Stmt_Decl = Stmt | Decl
  deriving (Eq, Ord, Show )

data Parameter = Param Modality Type Ident
  deriving (Eq, Ord, Show )

data Modality
    = M_Void
    | M_Val
    | M_Ref
    | M_Const
    | M_Res
    | M_Valres
    | M_Name
  deriving (Eq, Ord, Show )

data VarDeclar = VarDecl Ident ComplexRExpr
  deriving (Eq, Ord, Show )

{- sintax statement -}

data Stmt
    = Block [Stmt_Decl]
    | RetExpVoid 
    | RetExp RExpr
    | Assgn LExpr Assignment_op RExpr
    | PrePostIncDecr PrePost IncDecr LExpr
    | IfNoElse RExpr Stmt 
    | IfElse RExpr Stmt Stmt
    | While RExpr [LoopOp]
    | DoWhile [LoopOp] RExpr
    | For Stmt RExpr Stmt [LoopOp]
    | Comment String
  deriving (Eq, Ord, Show )

data LoopOp = Break | Continue | Stmt
  deriving (ER, Ord, Show) 

data Assignment_op
    = Assign
    | AssgnMul
    | AssgnAdd
    | AssgnDiv
    | AssgnSub
    | AssgnPow
    | AssgnAnd
    | AssgnOr
  deriving (Eq, Ord, Show ) 

{- Expr Syntax -}

data RExpr
    = InfixOp InfixOp RExpr RExpr
    | UnaryOp UnaryOp RExpr
    | Ref LExpr
    | FCall Ident [RExpr]
    | Const Const
    | Lexpr LExpr
  deriving (Eq, Ord, Show )

data InfixOp = ArithOp ArithOp | RelOp RelOp | BoolOp BoolOp
  deriving (Eq,Ord,Show)

data ArithOp = Add | Sub | Mul | Div | Mod | Pow
  deriving (Eq,Ord,Show)

data BoolOp = And | Or | Xor 
  deriving (Eq,Ord,Show)

data RelOp = Eq | Neq | Lt | LtE | Gt | GtE
  deriving (Eq,Ord,Show)

data UnaryOp = Not | Neg
  deriving (Eq,Ord,Show)

data Const = Bool Boolean | Char T_Char | Float T_Float | Int T_Int 
  deriving (Eq,Ord,Show )

data ComplexRExpr = Simple RExpr | Array [ComplexRExpr]
  deriving (Eq, Ord, Show )

data LExpr
    = Deref RExpr
    | Id Ident
    | ArrayEl LExpr RExpr
    | FCall Ident [RExpr]
  deriving (Eq, Ord, Show )

data PrePost = Post | Pre
  deriving (Eq,Ord,Show)

data IncDecr = Inc | Decr
  deriving (Eq,Ord,Show)
